#include <iostream>
#include <vector>


using namespace std;

vector <pair<int, int> > Tree[100]; // сама структура "дерева"
int depth[100][100]; // инициализирован нулями сначала
// короче первы индекс - номер вершины с которой мы рассматриваем подграф где эта вершина - корень
// второй индекс - количество ветвей которое нужно сохранить, а значение по этим двум индексам - искомое количество яблок(максимальное засчёт 26 строки)
// поэтому и выводим depth[0][Q] т.е считаем с корня оставляя Q ветвей
int DFS(int node, int parent, int Q) {
    int count = 0; //количество ветвей
    for(int i = 0; i < Tree[node].size(); i++) { // перебираем все вершины
        int child = Tree[node][i].first; // находим сына текущей вершины
        int apples = Tree[node][i].second; // кол-во яблок на текущей ветви
        if(child != parent) { // проверка на листья
            count += DFS(child, node, Q) + 1; // считаем сколько ветвей в подграфе с вершиной node
            for(int j = min(count, Q); j > 0; j--) { /* В общем тут надо начинать раскручивать с родителей листьев, в чём прикол?
 * для родителя листа вот эти циклы будут иметь вид j=1 k=1 (count = 1) т.е depth[node][1] = max(depth[node][1], depth[node][0] + depth[child][0] + apples); <=> depth[node][1] = max(0, 0 + 0 + apples) = apples
 * т.е чем выше мы идем по дереву к корню, тем больше мы собираем информации о том какое максимальное количество яблок при отрубе подграфа с корнем node засчёт 26 строки, которая по сути говорит,
 * бери то где больше останется. Типо мы для каждого ребенка проверяем кого лучше отрубить чтобы осталсь больше яблок
 *
 */
                for(int k = min(count, j); k > 0; k--)
                    depth[node][j] = max(depth[node][j], depth[node][k - 1] + depth[child][j - k] + apples); // т.е мы фактически выбираем между предыдущим значением и яблоками на узле от Node до child + макс яблок на промежуточных путях
            }
        }
    }
    return count;
}

int main()
{
    int N, Q, u, v, apples;
    cin >> N >> Q;
    for(int i = 0; i < N - 1; i++) {
        cin >> u >> v >> apples;
        u--;
        v--;
        Tree[u].push_back(make_pair(v, apples)); // делаем неориентированный подвешенный граф
        Tree[v].push_back(make_pair(u, apples));
    }
    DFS(0, -1, Q); // обход в глубину от корня
    cout << depth[0][Q];
    return 0;
}